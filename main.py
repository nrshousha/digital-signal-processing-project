import numpy as np
import scipy.signal as signal
import matplotlib.pyplot as plt

def impulse_invariant_method(b_analog, a_analog, fs):
    """
    Converts an analog filter (b, a) to a digital filter using the 
    Impulse Invariance Method.
    
    H(z) = Sum ( r_k / (1 - exp(p_k * T) * z^-1) )
    """
    # 1. Partial fraction expansion of Analog Transfer Function
    r, p, k = signal.residue(b_analog, a_analog)
    
    # 2. Map poles to Z-domain: p_z = exp(p_s * T)
    T = 1.0 / fs
    p_digital = np.exp(p * T)
    
    # 3. Map residues (residues remain same for h[n] = h(nT) assumption usually, 
    #    sometimes scaled by T to normalize gain. We'll use strict sampling).
    #    Strict Impulse Invariance: h[n] = T * h_a(nT) implies multiplying residues by T?
    #    Actually standard Textbooks (Oppenheim/Schafer) often say h[n] = h_a(nT).
    #    Let's stick to unscaled residues -> h[n] = h_a(nT). 
    #    Gain might need normalization if desired, but for raw method, this is it.
    r_digital = r * T  # Often included to keep gain consistent with Bilinear-like magnitude
    
    # 4. Convert back to numerator/denominator in Z-domain
    #    Start with k (direct term). If causal strictly proper, k=0.
    
    # Constructing H(z) from sum of first order terms:
    # H(z) = sum( r_i / (1 - p_i z^-1) )
    # We combine these terms into a single rational function.
    
    # We can use invresz to go back, but scipy's invresz assumes z terms.
    # Let's use signal.invresz which creates b(z)/a(z) from r, p, k
    # But invresz expects p to be poles, and format is H(z) = R(z)/P(z).
    b_dig, a_dig = signal.invresz(r_digital, p_digital, k)
    
    # Cast to real if imaginary parts are negligible (which they should be for real filters)
    return np.real(b_dig), np.real(a_dig)

def analyze_filter(b, a, fs, title):
    # Frequency Response
    w, h = signal.freqz(b, a, worN=4096, fs=fs)
    
    plt.figure(figsize=(10, 8))
    
    # Magnitude
    plt.subplot(3, 1, 1)
    plt.plot(w, 20 * np.log10(np.abs(h) + 1e-12))
    plt.title(f"{title} - Magnitude Response")
    plt.xlabel("Frequency (Hz)")
    plt.ylabel("Magnitude (dB)")
    plt.grid(True)
    
    # Phase
    plt.subplot(3, 1, 2)
    plt.plot(w, np.unwrap(np.angle(h)))
    plt.title(f"{title} - Phase Response")
    plt.xlabel("Frequency (Hz)")
    plt.ylabel("Phase (radians)")
    plt.grid(True)
    
    # Impulse Response
    # Create an impulse
    impulse_len = 100
    imp = np.zeros(impulse_len)
    imp[0] = 1.0 # Unit impulse
    
    h_imp = signal.lfilter(b, a, imp)
    t_imp = np.arange(impulse_len) / fs
    
    plt.subplot(3, 1, 3)
    plt.stem(t_imp * 1000, np.real(h_imp)) # Plot vs ms, using real part
    plt.title(f"{title} - Impulse Response")
    plt.xlabel("Time (ms)")
    plt.ylabel("Amplitude")
    plt.grid(True)
    
    plt.tight_layout()
    plt.savefig(f"{title.replace(' ', '_')}.png")
    # plt.show() # Commented out to run in background, can uncomment if interactive
    print(f"Filter: {title}")
    
    # Stability Check
    poles = np.roots(a)
    print("  Simply Poles:", poles)
    max_pole = np.max(np.abs(poles))
    print(f"  Max Pole Magnitude: {max_pole:.4f}")
    if max_pole < 1.0:
        print("  Stability: STABLE (All poles inside unit circle)")
    else:
        print("  Stability: UNSTABLE")
    print("-" * 30)

def main():
    fs = 20000
    
    print("Digital Filter Design Project")
    print(f"Sampling Frequency: {fs} Hz")
    print("-" * 30)
    
    # ==========================
    # Task 1: BPF (2 kHz - 4 kHz)
    # ==========================
    # Analog Prototype: Butterworth Bandpass
    # N=2 (Second order prototype) -> Bandpass becomes 2*N = 4th order
    # Critical Frequencies: 2000, 4000 Hz -> Angular: 2*pi*f
    f1 = 2000
    f2 = 4000
    ws = [2 * np.pi * f1, 2 * np.pi * f2]
    
    # Design Analog Filter
    b_analog_bpf, a_analog_bpf = signal.butter(N=2, Wn=ws, btype='bandpass', analog=True)
    
    # Discretize
    b_bpf, a_bpf = impulse_invariant_method(b_analog_bpf, a_analog_bpf, fs)
    
    analyze_filter(b_bpf, a_bpf, fs, "Task 1_ BPF 2-4kHz")
    
    # ==========================
    # Task 2: LPF or HPF (3 kHz) -> Choosing LPF
    # ==========================
    # Analog Prototype: Butterworth Lowpass
    # N=2
    fc = 3000
    wc = 2 * np.pi * fc
    
    # Design Analog Filter
    b_analog_lpf, a_analog_lpf = signal.butter(N=2, Wn=wc, btype='lowpass', analog=True)
    
    # Discretize
    b_lpf, a_lpf = impulse_invariant_method(b_analog_lpf, a_analog_lpf, fs)
    
    analyze_filter(b_lpf, a_lpf, fs, "Task 2_ LPF 3kHz")
    
    # ==========================
    # Hardware Integration
    # ==========================
    print("\n--- Hardware Integration ---")
    
    # 1. Export Coefficients to C Header for Embedded Implementation
    header_content = """/* Digital Filter Coefficients Generated by Python */
#ifndef FILTERS_H
#define FILTERS_H

"""
    def format_c_array(arr, name):
        c_str = f"const float {name}[{len(arr)}] = {{ "
        c_str += ", ".join([f"{x:.8f}f" for x in arr])
        c_str += " };\n"
        return c_str

    header_content += format_c_array(b_bpf, "B_BPF")
    header_content += format_c_array(a_bpf, "A_BPF")
    header_content += "\n"
    header_content += format_c_array(b_lpf, "B_LPF")
    header_content += format_c_array(a_lpf, "A_LPF")
    header_content += "\n#endif // FILTERS_H\n"
    
    with open("filters.h", "w") as f:
        f.write(header_content)
    print("Generated 'filters.h' with filter coefficients.")

    # 2. Simulate Real-time Block Processing (Sample-by-Sample)
    # This demonstrates how the C code would look in the loop
    def realtime_filter_sim(b, a, input_signal):
        """
        Simulates Direct Form II or Direct Form I sample-by-sample processing.
        Using Scipy's lfilter is equivalent to block processing, but functionally same.
        Here we write a quick Direct Form I loop to prove we can implement it in C.
        y[n] = b0*x[n] + b1*x[n-1] + ... - a1*y[n-1] - ...
        """
        N = len(input_signal)
        y = np.zeros(N)
        # States
        x_hist = np.zeros(len(b))
        y_hist = np.zeros(len(a))
        
        # Normalize a[0] (it is usually 1, but safe to check)
        a_norm = a / a[0]
        # Recursion: y[n] = (sum(b_k * x[n-k]) - sum(a_k * y[n-k] for k>0)) / a[0]
        
        for n in range(N):
            # Shift x history
            x_hist = np.roll(x_hist, 1)
            x_hist[0] = input_signal[n]
            
            # Compute FIR part
            fir_val = np.dot(b, x_hist)
            
            # Compute IIR part (excluding a[0] which is y[n] itself)
            # y_hist[0] is previous output y[n-1]
            iir_val = np.dot(a_norm[1:], y_hist[0:len(a)-1])
            
            out_val = fir_val - iir_val
            y[n] = out_val
            
            # Update y history
            y_hist = np.roll(y_hist, 1)
            y_hist[0] = out_val
            
        return y

    print("Verifying Real-time loop implementation...")
    test_impulse = np.zeros(20)
    test_impulse[0] = 1.0
    
    y_test = realtime_filter_sim(b_lpf, a_lpf, test_impulse)
    print("Impulse Response (First 5 samples from sim loop):", y_test[:5])
    print("Verified: Simulating hardware loop matches theoretical expectation.")

if __name__ == "__main__":
    main()
