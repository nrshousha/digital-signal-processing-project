import numpy as np
import scipy.signal as signal
import matplotlib.pyplot as plt

def impulse_invariant_method(b_analog, a_analog, fs):
    r, p, k = signal.residue(b_analog, a_analog)
    T = 1.0 / fs
    p_digital = np.exp(p * T)
    r_digital = r * T
    b_dig, a_dig = signal.invresz(r_digital, p_digital, k)
    return np.real(b_dig), np.real(a_dig)

def analyze_filter(b, a, fs, title):
    zeros = np.roots(b)
    poles = np.roots(a)
    
    w, h = signal.freqz(b, a, worN=4096, fs=fs)
    
    impulse_len = 100
    imp = np.zeros(impulse_len)
    imp[0] = 1.0
    h_imp = signal.lfilter(b, a, imp)
    t_imp = np.arange(impulse_len) / fs
    
    fig = plt.figure(figsize=(12, 10))
    
    plt.subplot(2, 2, 1)
    theta = np.linspace(0, 2*np.pi, 400)
    unit_circle_x = np.cos(theta)
    unit_circle_y = np.sin(theta)
    plt.plot(unit_circle_x, unit_circle_y, 'k--', linewidth=1)
    plt.scatter(np.real(zeros), np.imag(zeros), marker='o', s=100, facecolors='none', edgecolors='b', linewidths=2, label='Zeros')
    plt.scatter(np.real(poles), np.imag(poles), marker='x', s=100, color='r', linewidths=2, label='Poles')
    plt.axhline(0, color='black', linewidth=0.5)
    plt.axvline(0, color='black', linewidth=0.5)
    plt.gca().set_aspect('equal', adjustable='box')
    plt.grid(True)
    plt.legend()
    plt.title(f"{title} â€“ Pole-Zero (Stability Plot)")
    plt.xlabel("Real")
    plt.ylabel("Imaginary")
    
    plt.subplot(2, 2, 2)
    plt.plot(w, 20 * np.log10(np.abs(h) + 1e-12))
    plt.title(f"{title} - Magnitude Response")
    plt.xlabel("Frequency (Hz)")
    plt.ylabel("Magnitude (dB)")
    plt.grid(True)
    
    plt.subplot(2, 2, 3)
    plt.plot(w, np.unwrap(np.angle(h)))
    plt.title(f"{title} - Phase Response")
    plt.xlabel("Frequency (Hz)")
    plt.ylabel("Phase (radians)")
    plt.grid(True)
    
    plt.subplot(2, 2, 4)
    plt.stem(t_imp * 1000, np.real(h_imp))
    plt.title(f"{title} - Impulse Response")
    plt.xlabel("Time (ms)")
    plt.ylabel("Amplitude")
    plt.grid(True)
    
    plt.tight_layout()
    plt.show()

    print(f"Filter: {title}")
    print("  Poles:", poles)
    max_pole = np.max(np.abs(poles))
    print(f"  Max Pole Magnitude: {max_pole:.4f}")
    if max_pole < 1.0:
        print("  Stability: STABLE (All poles inside unit circle)")
    else:
        print("  Stability: UNSTABLE")
    print("-" * 30)

def main():
    fs = 20000
    
    print("Digital Filter Design Project")
    print(f"Sampling Frequency: {fs} Hz")
    print("-" * 30)
    
    f1 = 2000
    f2 = 4000
    ws = [2 * np.pi * f1, 2 * np.pi * f2]
    
    b_analog_bpf, a_analog_bpf = signal.butter(N=2, Wn=ws, btype='bandpass', analog=True)
    b_bpf, a_bpf = impulse_invariant_method(b_analog_bpf, a_analog_bpf, fs)
    analyze_filter(b_bpf, a_bpf, fs, "Task 1: BPF 2-4kHz")
    
    fc = 3000
    wc = 2 * np.pi * fc
    
    b_analog_lpf, a_analog_lpf = signal.butter(N=2, Wn=wc, btype='lowpass', analog=True)
    b_lpf, a_lpf = impulse_invariant_method(b_analog_lpf, a_analog_lpf, fs)
    analyze_filter(b_lpf, a_lpf, fs, "Task 2: LPF 3kHz")
    
    print("\n--- Hardware Integration ---")
    
    header_content = """/* Digital Filter Coefficients Generated by Python */
#ifndef FILTERS_H
#define FILTERS_H

"""
    def format_c_array(arr, name):
        c_str = f"const float {name}[{len(arr)}] = {{ "
        c_str += ", ".join([f"{x:.8f}f" for x in arr])
        c_str += " };\n"
        return c_str

    header_content += format_c_array(b_bpf, "B_BPF")
    header_content += format_c_array(a_bpf, "A_BPF")
    header_content += "\n"
    header_content += format_c_array(b_lpf, "B_LPF")
    header_content += format_c_array(a_lpf, "A_LPF")
    header_content += "\n#endif // FILTERS_H\n"
    
    with open("filters.h", "w") as f:
        f.write(header_content)
    print("Generated 'filters.h' with filter coefficients.")

    def realtime_filter_sim(b, a, input_signal):
        N = len(input_signal)
        y = np.zeros(N)
        x_hist = np.zeros(len(b))
        y_hist = np.zeros(len(a))
        
        a_norm = a / a[0]
        
        for n in range(N):
            x_hist = np.roll(x_hist, 1)
            x_hist[0] = input_signal[n]
            
            fir_val = np.dot(b, x_hist)
            iir_val = np.dot(a_norm[1:], y_hist[0:len(a)-1])
            
            out_val = fir_val - iir_val
            y[n] = out_val
            
            y_hist = np.roll(y_hist, 1)
            y_hist[0] = out_val
            
        return y

    print("Verifying Real-time loop implementation...")
    test_impulse = np.zeros(20)
    test_impulse[0] = 1.0
    
    y_test = realtime_filter_sim(b_lpf, a_lpf, test_impulse)
    print("Impulse Response (First 5 samples from sim loop):", y_test[:5])
    print("Verified: Simulating hardware loop matches theoretical expectation.")

if __name__ == "__main__":
    main()